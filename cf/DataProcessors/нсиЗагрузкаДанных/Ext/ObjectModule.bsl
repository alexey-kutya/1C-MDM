#Область СлужебныеПроцедурыИФункции

// Процедура - 	создает структуры объектов загрузки,
//				получает данные из файла и таблицы,
//				заполняет структуры значениями данных (в т.ч. выполняются алгоритмы),
//				создает объекты по структурам и полученным данным.
//
Процедура ЗагрузитьДанные(ИмяФайла, ИмяТаблицы, 
		ФормаРаботыСТаблицей, ПоляПоискаДанных, ЗначениеДанных, ПолученныеДанные, ПолученныеПроизвольныеДанные) Экспорт 
	
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(""+ТекущаяДата()+" - Началась обработка данных "+ИмяФайла+" "+ИмяТаблицы);
	
	ТаблицыПоиска = ПоляПоискаДанных.Скопировать();
	ТаблицыПоиска.Свернуть("ИмяРодителя");
	
	Если ФормироватьПакетнуюОбработку Тогда 
		ПакетнаяОбработка = БизнесПроцессы.нсиПакетныйВводЭлементовСправочника.СоздатьБизнесПроцесс();
		ПакетнаяОбработка.Автор = ПараметрыСеанса.ТекущийПользователь;
		ПакетнаяОбработка.ИмяСправочника = ИмяСправочника;
		ПакетнаяОбработка.Наименование = "Загружены данные " + Формат(ТекущаяДата(), "ДФ=dd.MM.yyyy");
		ПакетнаяОбработка.Дата = ТекущаяДата();
	КонецЕсли;	
	
	// создание структур для разбора данных
	СписокСтруктурОбъектов = Новый СписокЗначений;
	Для Каждого СтрокаТЧ Из ТаблицыПоиска Цикл 
		Если СтрокаТЧ.ИмяРодителя = "" Тогда 
			Продолжить;
		КонецЕсли;	
		СтруктураОбъекта = ПолучитьСтруктуруОбъекта(СтрокаТЧ.ИмяРодителя, 
			ТаблицыПоиска, ЗначениеДанных, ПолученныеДанные, ФормаРаботыСТаблицей);
		СписокСтруктурОбъектов.Добавить(СтруктураОбъекта);
	КонецЦикла;	
	СтруктурыОбъектаЭталона = ПолучитьСтруктуруОбъекта("",	ТаблицыПоиска, ЗначениеДанных, ПолученныеДанные, ФормаРаботыСТаблицей);
	
	// получение таблицы заполнения
	ТаблицаЗаполнения = ПолучитьТаблицуЗаполнения(ИмяФайла, ИмяТаблицы, ПолученныеДанные,ПолученныеПроизвольныеДанные,  Ложь);
	
	// заполнение доп данных и самой записи
	мОбработано = 0;
	Для Каждого СтрокаЗаполнения Из ТаблицаЗаполнения Цикл 
		
		Если ВыводитьЛогПоиска Тогда 
			ВывестиОписаниеОшибки(СтрокаЗаполнения.СтрокаДанных, "Началась обработка строки.");
		КонецЕсли;
		
		НачатьТранзакцию();
		Ошибка = Ложь;
		
		Для Каждого СтрокаТЧ Из СписокСтруктурОбъектов Цикл 
			СтруктураОбъекта = СтрокаТЧ.Значение;		
			ЗаполнитьПолученнымиДаннымиСтруктуру(ПолученныеДанные, СтрокаЗаполнения, СтруктураОбъекта, 
				СтруктураОбъекта.Получить("ИмяРодителя"), Ошибка);
			РезультатРазбора = РазобратьСтруктуруОбъекта(СтруктураОбъекта, ПоляПоискаДанных, СтрокаЗаполнения, Ошибка);	
			СтруктурыОбъектаЭталона.Вставить(СтруктураОбъекта.Получить("ИмяРодителя"), РезультатРазбора);
		КонецЦикла;	
		
		ЗаполнитьПолученнымиДаннымиСтруктуру(ПолученныеДанные, СтрокаЗаполнения, СтруктурыОбъектаЭталона, "", Ошибка);
		ОбработанЭлемент = РазобратьСтруктуруОбъекта(СтруктурыОбъектаЭталона, ПоляПоискаДанных, СтрокаЗаполнения, Ошибка);
		
		Если Ошибка Тогда 
			ВывестиОписаниеОшибки(СтрокаЗаполнения.СтрокаДанных, "Не удалось обработать данные (есть ошибка)!");
			ОтменитьТранзакцию();
			Продолжить;
		ИначеЕсли Не ОбработанЭлемент = Неопределено Тогда  	
			Если ФормироватьПакетнуюОбработку Тогда 
				НовыйПредмет = ПакетнаяОбработка.Предметы.Добавить();
				НовыйПредмет.Предмет = ОбработанЭлемент.Ссылка;
			КонецЕсли;	
			мОбработано = мОбработано + 1;
		Иначе 	
			ВывестиОписаниеОшибки(СтрокаЗаполнения.СтрокаДанных, "Не обработаны данные!");
		КонецЕсли;	
		
		Если ЗаписыватьДанныеПослеРазбора Тогда 
			ЗафиксироватьТранзакцию();
		Иначе 
			ОтменитьТранзакцию();
		КонецЕсли;
		
	КонецЦикла;
	
	Если ФормироватьПакетнуюОбработку Тогда 
		ПакетнаяОбработка.Записать();
	КонецЕсли;	
	
	ВывестиОписаниеОшибки(0, "Обработано позиций (создано/изменено записей) "+мОбработано+".");
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(""+ТекущаяДата()+" - Закончилась обработка данных "+ИмяФайла+" "+ИмяТаблицы);
	
КонецПроцедуры	

// функция - возвращает структуру разбора данных.
//
Функция ПолучитьСтруктуруОбъекта(ИмяРодителя, ТаблицыПоиска, ЗначениеДанных, ПолученныеДанные, ФормаРаботыСТаблицей)
	
	СтруктураОбъекта = Новый Соответствие;
	СтруктураОбъекта.Вставить("ИмяРодителя", ?(ИмяРодителя = "", Строка(ИмяСправочника), ИмяРодителя) );
	
	Для Каждого СтрокаТЧ Из ФормаРаботыСТаблицей Цикл 
		Если СтрокаТЧ.ИмяРеквизита = ?(ИмяРодителя = "", Строка(ИмяСправочника), ИмяРодителя) Тогда 
			СтруктураОбъекта.Вставить("ФормаРаботы", 		СтрокаТЧ.ФормаРаботы);
			СтруктураОбъекта.Вставить("ЗаполнятьЗначением", СтрокаТЧ.ЗаполнятьЗначением);
		КонецЕсли;	
	КонецЦикла;	
		
	Для Каждого СтрокаТЧ Из ЗначениеДанных Цикл 
		Если СтрокаТЧ.ИмяРодителя = ИмяРодителя Тогда 
			Если ТипЗнч(СтрокаТЧ.ИмяРеквизита) = Тип("Строка") Тогда 
				СтруктураОбъекта.Вставить(
					СтрЗаменить(СтрокаТЧ.ИмяРеквизита, ИмяРодителя+".", ""), 
					СтрокаТЧ.ЗаполнятьЗначением);
			Иначе 
				СтруктураОбъекта.Вставить(СтрокаТЧ.ИмяРеквизита, СтрокаТЧ.ЗаполнятьЗначением);
			КонецЕсли;	
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого СтрокаТЧ Из ПолученныеДанные Цикл 
		Если СтрокаТЧ.ИмяРодителя = ИмяРодителя Тогда 
			Если ТипЗнч(СтрокаТЧ.ИмяРеквизита) = Тип("Строка") Тогда 
				СтруктураОбъекта.Вставить(
					СтрЗаменить(СтрокаТЧ.ИмяРеквизита, ИмяРодителя+".", ""), 
					Неопределено);
			Иначе 
				СтруктураОбъекта.Вставить(СтрокаТЧ.ИмяРеквизита, Неопределено);
			КонецЕсли;	
		КонецЕсли;
	КонецЦикла;
	
	Если ИмяРодителя = "" Тогда 
		Для Каждого СтрокаТЧ Из ТаблицыПоиска Цикл 
			Если Не СтрокаТЧ.ИмяРодителя = "" Тогда 
				СтруктураОбъекта.Вставить(СтрокаТЧ.ИмяРодителя, Неопределено)
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат СтруктураОбъекта;
	
КонецФункции

// Функция - получает данные из внешнего источника и возвращает в виде ТЗ.
//
Функция ПолучитьТаблицуЗаполнения(ИмяФайла, ИмяТаблицы, ПолученныеДанные, ПолученныеПроизвольныеДанные, ОтказПродолжения)
	
	ТаблицыПоиска = ПолученныеДанные.Скопировать();
	ТаблицыПоиска.Свернуть("НомерПозиции");
	
	// создание таблицы
	ТаблицаЗаполнения = Новый ТаблицаЗначений;
	ТаблицаЗаполнения.Колонки.Добавить("СтрокаДанных");
	Для Каждого СтрокаТЧ Из ПолученныеДанные Цикл 
		ТаблицаЗаполнения.Колонки.Добавить("Данные"+СтрокаТЧ.НомерПозиции);
	КонецЦикла;	
	Для Каждого СтрокаТЧ Из ПолученныеПроизвольныеДанные Цикл 
		ТаблицаЗаполнения.Колонки.Добавить("ДопДанные"+СтрокаТЧ.НомерПозиции);
	КонецЦикла;	
	
	// подключение к данным
	Connection = ОткрытьConnection(ИмяФайла, ОтказПродолжения);
	Если ОтказПродолжения Тогда 
		Возврат ТаблицаЗаполнения;
	КонецЕсли;	
	
	// выборка данных
	RecordSet = ПолучитьДанныеConnection(Connection, ИмяТаблицы, ОтказПродолжения);
	Если ОтказПродолжения Тогда 
		Возврат ТаблицаЗаполнения;
	КонецЕсли;	
	
	ВывестиОписаниеОшибки(0, "Подключение успешно установлено. Считываются данные.");
	
	// обход данных
	НомерСтроки = 1;
	RecordSet.MoveNext();	
	Пока RecordSet.EOF() = 0 Цикл
		
		НомерСтроки = НомерСтроки + 1;
		
		// если строка полностью пустая - данные не заносятся в ТЗ
		СтрокаЗаполнена = Ложь;
		Для Каждого СтрокаТЧ Из ПолученныеДанные Цикл 
			мЗначение = RecordSet.Fields(СтрокаТЧ.НомерПозиции - 1).Value;
			Если Не мЗначение = NULL Тогда 
				СтрокаЗаполнена = Истина;
			КонецЕсли;	
			Если СтрокаТЧ.ОбязательноеПоле Тогда  
				Если (мЗначение = NULL ИЛИ мЗначение = Дата(1,1,1) ИЛИ мЗначение = 0 ИЛИ СокрЛП(мЗначение) = "") Тогда 
					СтрокаЗаполнена = Ложь;
					ВывестиОписаниеОшибки(НомерСтроки, "Не заполнено обязательное поле "+СтрокаТЧ.ИмяРеквизита);
					Прервать;
				КонецЕсли;	
			КонецЕсли;	
		КонецЦикла;	
		Для Каждого СтрокаТЧ Из ПолученныеПроизвольныеДанные Цикл 
			мЗначение = RecordSet.Fields(СтрокаТЧ.НомерПозиции - 1).Value;
			Если Не мЗначение = NULL Тогда 
				СтрокаЗаполнена = Истина;
			КонецЕсли;	
			Если СтрокаТЧ.ОбязательноеПоле Тогда  
				Если (мЗначение = NULL ИЛИ мЗначение = Дата(1,1,1) ИЛИ мЗначение = 0 ИЛИ СокрЛП(мЗначение) = "") Тогда 
					СтрокаЗаполнена = Ложь;
					ВывестиОписаниеОшибки(НомерСтроки, "Не заполнено обязательное доп. поле "+СтрокаТЧ.ИмяРеквизита);
					Прервать;
				КонецЕсли;	
			КонецЕсли;	
		КонецЦикла;	
		Если Не СтрокаЗаполнена Тогда 
			RecordSet.MoveNext();  		
			Продолжить;
		КонецЕсли;	   		
		
		// занесение данных в ТЗ
		Если ВыводитьЛогСчитанных Тогда 
			ВывестиОписаниеОшибки(НомерСтроки, "Считываются данные строки.");
		КонецЕсли;
		НоваяСтрока = ТаблицаЗаполнения.Добавить();
		НоваяСтрока.СтрокаДанных = НомерСтроки;
		Для Каждого СтрокаТЧ Из ПолученныеДанные Цикл 
			НоваяСтрока["Данные"+СтрокаТЧ.НомерПозиции] = RecordSet.Fields(СтрокаТЧ.НомерПозиции - 1).Value;
			Если ВыводитьЛогСчитанных Тогда 
				ВывестиОписаниеОшибки(0, "	Данные"+(СтрокаТЧ.НомерПозиции - 1)+" ("+НоваяСтрока["Данные"+СтрокаТЧ.НомерПозиции]+")");
			КонецЕсли;
		КонецЦикла;	
	
		Для Каждого СтрокаТЧ Из ПолученныеПроизвольныеДанные Цикл 
			мЗначение = RecordSet.Fields(СтрокаТЧ.НомерПозиции - 1).Value;
			Если ЗначениеЗаполнено(СтрокаТЧ.АлгоритмРазбора) Тогда 
				мЗначение = ВыполнитьАлгоритмРазбора(СтрокаТЧ.АлгоритмРазбора, мЗначение, Ложь);
			КонецЕсли;

			НоваяСтрока["ДопДанные"+СтрокаТЧ.НомерПозиции] = мЗначение;
			Если ВыводитьЛогСчитанных Тогда 
				ВывестиОписаниеОшибки(0, "	ДопДанные"+(СтрокаТЧ.НомерПозиции - 1)+" ("+НоваяСтрока["ДопДанные"+СтрокаТЧ.НомерПозиции]+")");
			КонецЕсли;
		КонецЦикла;	
		
		RecordSet.MoveNext();  		
	КонецЦикла;
	
	RecordSet.Close();            
	Connection.Close();
	
	ВывестиОписаниеОшибки(0, "Считано "+НомерСтроки+" позиций, из них в обработку отправлено "+ТаблицаЗаполнения.Количество()+".");
	
	Возврат ТаблицаЗаполнения;
	
КонецФункции	

// Процедура - заполняет из строки данных структуру.
//
Процедура ЗаполнитьПолученнымиДаннымиСтруктуру(ПолученныеДанные, СтрокаЗаполнения, СтруктураОбъекта, ИмяРодителя, Ошибка)
	
	Для Каждого СтрокаПолученныеДанные Из ПолученныеДанные Цикл 
		Если СтрокаПолученныеДанные.ИмяРодителя = ИмяРодителя Тогда 
			
			Значение = СтрокаЗаполнения["Данные"+СтрокаПолученныеДанные.НомерПозиции];
			Если ЗначениеЗаполнено(СтрокаПолученныеДанные.АлгоритмРазбора) Тогда 
				Значение = ВыполнитьАлгоритмРазбора(СтрокаПолученныеДанные.АлгоритмРазбора, Значение, Ошибка);
			КонецЕсли;
			
			СтруктураОбъекта.Вставить( 
				?(ТипЗнч(СтрокаПолученныеДанные.ИмяРеквизита) = Тип("Строка"),
					СтрЗаменить(СтрокаПолученныеДанные.ИмяРеквизита, ИмяРодителя+".", ""), 
					СтрокаПолученныеДанные.ИмяРеквизита), 
				Значение);
				
		КонецЕсли;	
	КонецЦикла;	
	
КонецПроцедуры	

// Функция - возвращает элемент справочника созданный на основании переданной структуры.
//
Функция РазобратьСтруктуруОбъекта(СтруктураОбъекта, ПоляПоискаДанных, СтрокаЗаполнения, Ошибка)
	
	ФормаРаботы = СтруктураОбъекта.Получить("ФормаРаботы");
	
	//Для Каждого СтрокаТЧ Из ПоляПоискаДанных Цикл 
	//	Если СтрокаТЧ.ОбязательноеПоле 
	//		И СтруктураОбъекта.Получить("ИмяРодителя") = 
	//		?(СтрокаТЧ.ИмяРодителя = "", ИмяСправочника, СтрокаТЧ.ИмяРодителя) 
	//		И Не ЗначениеЗаполнено(СтруктураОбъекта.Получить(
	//		СтрЗаменить(СтрокаТЧ.ИмяРеквизита, СтрокаТЧ.ИмяРодителя+".", "")) ) Тогда 
	//		Ошибка = Истина;
	//		Возврат Неопределено;
	//	КонецЕсли;	
	//КонецЦикла;	
	
	// если создание - создаем, иначе сначала ищем
	СтрокаПолей = "";
	Если ФормаРаботы = "Создание" Тогда 
		СоздаваемыйЭлемент = Справочники[СтруктураОбъекта.Получить("ЗаполнятьЗначением").Метаданные().Имя];
		СоздаваемыйЭлемент = СоздаваемыйЭлемент.СоздатьЭлемент();
	Иначе 
		
		Если ТипЗнч(ИмяСправочника) <> Тип("СправочникСсылка.нсиВидыСправочников") Тогда
		
			Запрос = Новый Запрос;
			Запрос.Текст = 
				"ВЫБРАТЬ
	           	|	ИскомаяТаблица.Ссылка
	           	|ИЗ
	           	|	Справочник."+СтруктураОбъекта.Получить("ЗаполнятьЗначением").Метаданные().Имя+" КАК ИскомаяТаблица
	           	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.нсиСтатусыОбработкиСправочников КАК СтатусыОбработки
	           	|		ПО ИскомаяТаблица.Ссылка = СтатусыОбработки.Объект
	           	|ГДЕ
	           	|	(НЕ ЕСТЬNULL(СтатусыОбработки.ВременныйЭлемент,ЛОЖЬ))";
			Для Каждого СтрокаТЧ Из ПоляПоискаДанных Цикл 
				Если Не СтруктураОбъекта.Получить("ИмяРодителя") = ?(СтрокаТЧ.ИмяРодителя = "", ИмяСправочника, СтрокаТЧ.ИмяРодителя) Тогда 
					Продолжить;
				КонецЕсли;	
				ПолеПоиска 		= СтрЗаменить(СтрокаТЧ.ИмяРеквизита, СтрокаТЧ.ИмяРодителя+".", "");
				Запрос.Текст 	= Запрос.Текст + Символы.ПС + "	И ИскомаяТаблица." + ПолеПоиска + " =  &" + ПолеПоиска;
				Запрос.УстановитьПараметр(ПолеПоиска, СтруктураОбъекта.Получить(ПолеПоиска));
				
				СтрокаПолей = СтрокаПолей + ?(ПустаяСтрока(СтрокаПолей), "", Символы.ПС) + "Поле " + ПолеПоиска + " = " + Строка(СтруктураОбъекта.Получить(ПолеПоиска));
				
				Если ВыводитьЛогПоиска Тогда 
					ВывестиОписаниеОшибки(0, "	Поиск ("+СтруктураОбъекта.Получить("ЗаполнятьЗначением").Метаданные().Имя+ПолеПоиска+") по ("+СтруктураОбъекта.Получить(ПолеПоиска)+")");
				КонецЕсли;
				
			КонецЦикла;	
			
		Иначе 
			
			Запрос = Новый Запрос;
			Запрос.Текст = 
				"ВЫБРАТЬ
	           	|	ИскомаяТаблица.Ссылка
	           	|ИЗ
	           	|	Справочник."+СтруктураОбъекта.Получить("ЗаполнятьЗначением").Метаданные().Имя+" КАК ИскомаяТаблица
	           	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.нсиСтатусыОбработкиСправочников КАК СтатусыОбработки
	           	|		ПО ИскомаяТаблица.Ссылка = СтатусыОбработки.Объект
	           	|ГДЕ
	           	|	(НЕ ЕСТЬNULL(СтатусыОбработки.ВременныйЭлемент,ЛОЖЬ))
				|	И ИскомаяТаблица.Владелец = &ВидСправочника";
			Запрос.УстановитьПараметр("ВидСправочника", ИмяСправочника);
			Для Каждого СтрокаТЧ Из ПоляПоискаДанных Цикл 
				Если Не СтруктураОбъекта.Получить("ИмяРодителя") = ?(СтрокаТЧ.ИмяРодителя = "", Строка(ИмяСправочника), СтрокаТЧ.ИмяРодителя) Тогда 
					Продолжить;
				КонецЕсли;	
				ПолеПоиска 		= СтрЗаменить(СтрокаТЧ.ИмяРеквизита, СтрокаТЧ.ИмяРодителя+".", "");
				Запрос.Текст 	= Запрос.Текст + Символы.ПС + "	И ИскомаяТаблица." + ПолеПоиска + " =  &" + ПолеПоиска;
				Запрос.УстановитьПараметр(ПолеПоиска, СтруктураОбъекта.Получить(ПолеПоиска));
				
				СтрокаПолей = СтрокаПолей + ?(ПустаяСтрока(СтрокаПолей), "", Символы.ПС) + "Поле " + ПолеПоиска + " = " + Строка(СтруктураОбъекта.Получить(ПолеПоиска));
				
				Если ВыводитьЛогПоиска Тогда 
					ВывестиОписаниеОшибки(0, "	Поиск ("+СтруктураОбъекта.Получить("ЗаполнятьЗначением").Метаданные().Имя+ПолеПоиска+") по ("+СтруктураОбъекта.Получить(ПолеПоиска)+")");
				КонецЕсли;
				
			КонецЦикла;	
			
		КонецЕсли;
		
	КонецЕсли;                         
	
	// если поиск - только ищем, иначе - ищем и создаем
	Если ФормаРаботы = "Поиск" Тогда 
		ВыборкаДетальныеЗаписи = Запрос.Выполнить().Выбрать();
		Если ВыборкаДетальныеЗаписи.Количество() > 1 Тогда
			ВывестиОписаниеОшибки(0, "Найдено несколько позиций по полю "+СтруктураОбъекта.Получить("ИмяРодителя") + ?(Не ПустаяСтрока(СтрокаПолей), Символы.ПС + "Значения для поиска: " + Символы.ПС + СтрокаПолей, ""));
			//ВывестиОписаниеОшибки(0, "Найдено несколько позиций по полю "+СтруктураОбъекта.Получить("ИмяРодителя"));
			Ошибка = Истина;
			Возврат Неопределено;
		КонецЕсли;
		Если ВыборкаДетальныеЗаписи.Следующий() Тогда 
			Возврат ВыборкаДетальныеЗаписи.Ссылка;     
		Иначе 
			Возврат Неопределено;
		КонецЕсли;	
	ИначеЕсли ФормаРаботы = "Поиск и изменение" Тогда 
		ВыборкаДетальныеЗаписи = Запрос.Выполнить().Выбрать();
		Если ВыборкаДетальныеЗаписи.Количество() > 1 Тогда 
			ВывестиОписаниеОшибки(0, "Найдено несколько позиций по полю "+СтруктураОбъекта.Получить("ИмяРодителя") + ?(Не ПустаяСтрока(СтрокаПолей), Символы.ПС + "Значения для поиска: " + Символы.ПС + СтрокаПолей, ""));
			//ВывестиОписаниеОшибки(0, "Найдено несколько позиций по полю "+СтруктураОбъекта.Получить("ИмяРодителя"));
			Ошибка = Истина;
			Возврат Неопределено;
		КонецЕсли;
		Если ВыборкаДетальныеЗаписи.Следующий() Тогда 
			СоздаваемыйЭлемент = ВыборкаДетальныеЗаписи.Ссылка.ПолучитьОбъект();     
		Иначе 
			Возврат Неопределено;
		КонецЕсли;	
	ИначеЕсли ФормаРаботы = "Поиск или создание" Тогда 
		ВыборкаДетальныеЗаписи = Запрос.Выполнить().Выбрать();
		Если ВыборкаДетальныеЗаписи.Следующий() Тогда 
			Возврат ВыборкаДетальныеЗаписи.Ссылка; 
		Иначе 	
			СоздаваемыйЭлемент = Справочники[СтруктураОбъекта.Получить("ЗаполнятьЗначением").Метаданные().Имя];
			СоздаваемыйЭлемент = СоздаваемыйЭлемент.СоздатьЭлемент();
		КонецЕсли;	 	
	ИначеЕсли ФормаРаботы = "Изменение или создание" Тогда 
		ВыборкаДетальныеЗаписи = Запрос.Выполнить().Выбрать();
		Если ВыборкаДетальныеЗаписи.Количество() > 1 Тогда
			ВывестиОписаниеОшибки(0, "Найдено несколько позиций по полю "+СтруктураОбъекта.Получить("ИмяРодителя") + ?(Не ПустаяСтрока(СтрокаПолей), Символы.ПС + "Значения для поиска: " + Символы.ПС + СтрокаПолей, ""));
			//ВывестиОписаниеОшибки(0, "Найдено несколько позиций по полю "+СтруктураОбъекта.Получить("ИмяРодителя"));
			Ошибка = Истина;
			Возврат Неопределено;
		КонецЕсли;
		Если ВыборкаДетальныеЗаписи.Следующий() Тогда 
			СоздаваемыйЭлемент = ВыборкаДетальныеЗаписи.Ссылка.ПолучитьОбъект(); 
		Иначе 	
			СоздаваемыйЭлемент = Справочники[СтруктураОбъекта.Получить("ЗаполнятьЗначением").Метаданные().Имя];
			СоздаваемыйЭлемент = СоздаваемыйЭлемент.СоздатьЭлемент();
		КонецЕсли;	 	
	КонецЕсли;
	
	Если ТипЗнч(ИмяСправочника) = Тип("СправочникСсылка.нсиВидыСправочников") Тогда
		СоздаваемыйЭлемент.Владелец = ИмяСправочника;
		СоздаваемыйЭлемент.ДополнительныеСвойства.Вставить("Данные", нсиУниверсальноеХранилище.ПолучитьМетаданные(ИмяСправочника)["Реквизиты"]);
	КонецЕсли;
	
	// заполнение основных реквизитов
	Для Каждого Реквизит Из СоздаваемыйЭлемент.Ссылка.Метаданные().СтандартныеРеквизиты Цикл
		Для Каждого КлючСвойства Из СтруктураОбъекта Цикл 
			Если КлючСвойства.Ключ = Реквизит.Имя Тогда 
				СоздаваемыйЭлемент[Реквизит.Имя] = КлючСвойства.Значение;
			КонецЕсли;	
		КонецЦикла;	
	КонецЦикла;	
	Для Каждого Реквизит Из СоздаваемыйЭлемент.Ссылка.Метаданные().Реквизиты Цикл
		Для Каждого КлючСвойства Из СтруктураОбъекта Цикл 
			Если КлючСвойства.Ключ = Реквизит.Имя Тогда 
				СоздаваемыйЭлемент[Реквизит.Имя] = КлючСвойства.Значение;
			КонецЕсли;	
		КонецЦикла;	
	КонецЦикла;	
	Если ТипЗнч(ИмяСправочника) = Тип("СправочникСсылка.нсиВидыСправочников") Тогда
		Для Каждого Реквизит Из ИмяСправочника.Реквизиты Цикл
			Для Каждого КлючСвойства Из СтруктураОбъекта Цикл 
				Если КлючСвойства.Ключ = Реквизит.Имя Тогда 
					СоздаваемыйЭлемент.ДополнительныеСвойства.Данные[Реквизит.Имя] = КлючСвойства.Значение;
				КонецЕсли;	
			КонецЦикла;	
		КонецЦикла;	
	КонецЕсли;
		
	
	// дополнительные реквизиты
	Для Каждого КлючСвойства Из СтруктураОбъекта Цикл 
		Если ТипЗнч(КлючСвойства.Ключ) = Тип("ПланВидовХарактеристикСсылка.ДополнительныеРеквизитыИСведения") Тогда 
			
			НайденКлюч = Ложь;
			Для Каждого СтрокаТЧ Из СоздаваемыйЭлемент.ДополнительныеРеквизиты Цикл 
				Если СтрокаТЧ.Свойство = КлючСвойства.Ключ Тогда  
					НайденКлюч = Истина;
					СтрокаТЧ.Значение = КлючСвойства.Значение; 
				КонецЕсли;	
			КонецЦикла;	
			Если Не НайденКлюч Тогда 
				СтрокаТЧ = СоздаваемыйЭлемент.ДополнительныеРеквизиты.Добавить();
				СтрокаТЧ.Свойство = КлючСвойства.Ключ;
				СтрокаТЧ.Значение = КлючСвойства.Значение; 
			КонецЕсли;	
			
		КонецЕсли;	
	КонецЦикла;	
	
	Если ФормироватьПакетнуюОбработку И СоздаваемыйЭлемент.ЭтоНовый()
		И СтруктураОбъекта.Получить("ИмяРодителя") = ИмяСправочника Тогда 
		СоздаваемыйЭлементСсылка = Справочники[ИмяСправочника].ПолучитьСсылку();
		СоздаваемыйЭлемент.УстановитьСсылкуНового(СоздаваемыйЭлементСсылка);
		РегистрыСведений.нсиСтатусыОбработкиСправочников.УстановитьСтатусСправочника(СоздаваемыйЭлементСсылка,
			Новый Структура("Пользователь,ВременныйЭлемент", ПараметрыСеанса.ТекущийПользователь, Истина));
	КонецЕсли;
		
	//Если ТипЗнч(ИмяСправочника) = Тип("СправочникСсылка.нсиВидыСправочников") Тогда
	//	СоздаваемыйЭлемент.Владелец = ИмяСправочника;
	//	СоздаваемыйЭлемент.ДополнительныеСвойства.Вставить("Данные", нсиУниверсальноеХранилище.ПолучитьМетаданные(ИмяСправочника)["Реквизиты"]);
	//КонецЕсли;
	
	Попытка
		Выполнить(ПередЗаписьюДанных);  
	Исключение
		Ошибка = Истина;
		ВывестиОписаниеОшибки(0, "Не корректно работает алгоритм ""ПередЗаписьюДанных"".");
		ВывестиОписаниеОшибки(0, "	"+ОписаниеОшибки());
		Возврат Неопределено;
	КонецПопытки;
	
	Попытка
		СоздаваемыйЭлемент.Записать();
	Исключение
		Ошибка = Истина;
		ВывестиОписаниеОшибки(0, "Не удалось записать данные "+СоздаваемыйЭлемент);
		ВывестиОписаниеОшибки(0, "	"+ОписаниеОшибки());
	КонецПопытки;
	
	Возврат СоздаваемыйЭлемент.Ссылка;
	                                           
КонецФункции	

// Функция - выполняет для требуемого значения заданный алгоритм.
//
Функция ВыполнитьАлгоритмРазбора(Алгоритм, Значение, Ошибка)
	
	Результат = Неопределено;
	
	Попытка
		Выполнить(Алгоритм.КодАлгоритма);
		Возврат Результат;
	Исключение
		Ошибка = Истина;
		ВывестиОписаниеОшибки(0, "Не корректно работает алгоритм "+Алгоритм);
		ВывестиОписаниеОшибки(0, "	"+ОписаниеОшибки());
		Возврат Неопределено;
	КонецПопытки;
	
	
КонецФункции	

////////////////////////////////////////////////////////////////////////////////
// ВЫБОРКА ДАННЫХ ЧЕРЕЗ ADODB
                                  
// Функция - открывает ADODB соединение.
//
Функция ОткрытьConnection(ИмяФайла, ОтказПродолжения = Ложь) Экспорт 
	
	СтрокаПодключения = СтрЗаменить(СтрокаПодключенияOLEDB, "file", ИмяФайла);
	СтрокаПодключения = СтрЗаменить(СтрокаПодключения, Символы.ПС, "");
	
	Попытка
		Connection = Новый COMОбъект("ADODB.Connection");
		Connection.Open(СокрЛП(СтрокаПодключения));
	Исключение
		Если ЗначениеЗаполнено(ИмяФайла) Тогда 
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Не удалось подключить файл " + ИмяФайла);
		Иначе 
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Не удалось подключиться к данным");
		КонецЕсли;
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ОписаниеОшибки());
		ОтказПродолжения = Истина;
		Возврат Неопределено;
	КонецПопытки;
	
	Возврат Connection;
		
КонецФункции	

// Функция - считывает данные по открытому соединению для указанной таблицы. 
//
Функция ПолучитьДанныеConnection(Connection, ИмяТаблицы, ОтказПродолжения)
	
	Попытка         
	Command 	= Новый COMОбъект("ADODB.Command");
	Command.ActiveConnection = Connection;
	Command.CommandText = СтрЗаменить(ЗапросOLEDB, "&ИмяТаблицы", ИмяТаблицы);
		RecordSet = Command.Execute();
	Исключение 
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Не удалось получить данные из " + ИмяТаблицы);
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ОписаниеОшибки());
		ОтказПродолжения = Истина;
		Возврат Неопределено;
	КонецПопытки;
	
	Возврат RecordSet;
	
КонецФункции	

// Функция - получает имя листа по номеру.
//
Функция ПолучитьИмяЛиста(Connection, НомерЛиста, ОтказПродолжения = Ложь) Экспорт
	
	Попытка       		
		axCatalog 	= Новый COMОбъект("ADOX.Catalog");                                                
		axCatalog.ActiveConnection = Connection; 
		ИмяТаблицы = axCatalog.Tables.Item(НомерЛиста-1).Name;     	
	Исключение
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Не удалось получить лист " + НомерЛиста);
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ОписаниеОшибки());
		ОтказПродолжения = Истина;
		Возврат "";
	КонецПопытки;
	
	Возврат ИмяТаблицы;
		
КонецФункции	

// Функция - получает список листов для xls файла.
//
Функция ПолучитьСписокЛистов(Connection, ОтказПродолжения = Ложь) Экспорт
	
	Список = Новый СписокЗначений;
	
	Попытка       		
		axCatalog 	= Новый COMОбъект("ADOX.Catalog");                                                
		axCatalog.ActiveConnection = Connection; 
		Для мНомерЛиста = 0 По axCatalog.Tables.Count-1 Цикл 
			Список.Добавить(axCatalog.Tables.Item(мНомерЛиста).Name,axCatalog.Tables.Item(мНомерЛиста).Name);
		КонецЦикла;	
	Исключение
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Не удалось прочитать листы");
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ОписаниеОшибки());
		ОтказПродолжения = Истина;
		Возврат Список;
	КонецПопытки;
	
	Возврат Список;
		
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ОБЩЕГО НАЗНАЧЕНИЯ

// Функция - выводит ошибочные и информационные сообщения.
//
Процедура ВывестиОписаниеОшибки(НомерСтроки, ТекстОшибки);
	
	Если НомерСтроки = 0 Тогда 
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("		" + ТекстОшибки);
	Иначе 	
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("		[" + (НомерСтроки) + "] " + ТекстОшибки);
	КонецЕсли;
		
КонецПроцедуры	


#КонецОбласти
	
	
	

